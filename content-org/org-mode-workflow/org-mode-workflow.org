#+options: ':nil -:nil ^:{} num:nil toc:t
#+author: Kristian Alexander P
#+creator: Emacs 29.2 (Org mode 9.6.15 + ox-hugo)
#+hugo_section: posts
#+hugo_base_dir: ../../
#+date: <2024-03-14 Thu>
#+title: Org Mode Workflow
#+description: Getting Things Done with /Emacs/
#+hugo_draft: false
#+hugo_tags: emacs org-mode org GTD
#+hugo_categories: emacs
#+hugo_auto_set_lastmod: t
#+startup: inlineimages

* How I mapped my brain to /org-mode/
Initially, this post was titled /Getting Things Done in Emacs/. But as I keep adding more information into this post, and how I interact with /org-mode/ and /Emacs/ in general, it was about capturing my thought process. Tasks is one thing, and the important one since that's what I'm paid for.

I've used /Emacs/ for more than five years now it's becoming hard for me to open up my laptop / PC, and not having /Emacs/ auto-started.

Lately I found that I am in dire need of an effective task management system as an /IT/ support. There are some days where everything is hectic and I'm lost prioritizing my assignments. There's moment where I was in the middle of doing one task, and suddenly another request / assignment came out of nowhere (not exactly nowhere, but you get the idea). Task management system is also useful for creating some kind of reporting, although this is not the main goal.

Basically what I want is:
- [X] daily planner.
- [X] Simple UI for task highlighting or focusing.
- [X] automation or templating for capturing tasks.
- [X] reviewing
- [X] Sync between Laptop, PC, and android

* Using /org-mode/
#+begin_src plantuml :file ./task-flow.svg :exports results
title Life of a Tasks

:incoming;
:org-capture;
note right
Capture as much details as possible
end note
    if (require action?) then (yes)
    -[#81a1c1]->
    note
    tasks
    end note
    #bf616a:mark it TODO;
  if (more than one action?) then (yes)
    :project;
    note left
    will have separate sub tasks
    end note
    kill
  else (no)
    :determine next action;
    if (will it takes less than 2 minutes) then (yes)
      note
      prioritize this when possible
      endnote
      #a3be8c:do it now and mark it DONE;
      kill
    else (no)
      if (can it be done by myself?) then (yes)
        :defer it;
        note
          do other high priority tasks when possible
        end note
        if (should it be done at specific time?) then (yes)
          #bf616a:schedule and mark it TODO;
          kill
        else (no)
          #81a1c1:mark it NEXT;
          kill
        endif
      else (no)
        :delegate;
        if (will I have to process after delegation?) then (yes)
          #5e81ac:mark it PROG;
        else (no)
          #8fbcbb:mark it DELEGATE;
        endif
        kill
      endif
    endif
  endif
else (no)
  -[#a3be8c]->
  note right
  information
  end note
  if (worth keeping?) then (yes)
    if (require action later) then (yes)
      #81a1c1:mark it NEXT;
      note
      ideas etc
      end note
    else (no)
      #88c0d0:reference;
      split 
        :org-roam;
        kill
      split again
        :org-journal;
        kill
      split again
        :notes;
        kill
      end split
    endif
    kill
  else (no)
    #a3be8c:archive it,
    mark it DONE if
    necessary;
  endif
  kill
endif
#+end_src

#+RESULTS:
[[file:./task-flow.svg]]
An /Emacs/ nerd as I am, of course the first stop is =org-mode=. Please forgive this messy chart since I'm still learning on /[[https://plantuml.com/][plantuml]]/.

I really want to try from the ground up, using a /vanilla/ /Emacs/ with no interference from my actual configuration file[fn:1]. First of all, we need to set the minimal keybinding suggested by the [[https://orgmode.org/manual/Activation.html][manual]]:

** Keybindings
#+caption: suggested keybindings
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c l") #'org-store-link)
  (global-set-key (kbd "C-c a") #'org-agenda)
  (global-set-key (kbd "C-c c") #'org-capture)
#+end_src

** Specific =org-mode= variables
:PROPERTIES:
:ID:       705c247a-a878-46fc-aff6-3fc1d3b548a6
:END:

*** =org-directory= and =org-agenda-files=
Next is set the =org-directory=, this directory is going to be the location of =org-mode= files, well, you are free to place an =org-mode= files anywhere, but think of this as the /root/ location, so every customizations we'll be making will refers to this location, for example, if we want to define our =org-agenda-files= as =agenda.org= inside the =org-directory=, we'll use:
#+caption: set the location of =org-directory= inside =user-emacs-directory=
#+begin_src emacs-lisp
  (setq org-directory (expand-file-name "org" user-emacs-directory))
#+end_src
Usually you'll want your =org-directory= to be separated from your =user-emacs-directory=, which mostly be under some kind of version control system (such as /git/). The simplest location is just on the root of your =home-directory=

#+caption: set the location of =org-directory= on the root of your home directory
#+begin_src emacs-lisp
  (setq org-directory (expand-file-name "org" (getenv "HOME"))) ;; ~/org/
#+end_src

Assuming your =user-emacs-directory= is in =~/.emacs.d~=, then your =org-directory= is =~/.emacs.d/org=

#+caption: set the location of =org-agenda-files=
#+begin_src emacs-lisp
  (setq org-agenda-files (list org-directory))
#+end_src

*** =org-archive-location=
=org-archive-location= is another variable that I should consider, will I want an archiving method? If I do, where should I put it? Is storing archived task (the done, cancelled etc) in a designated file necessary?

*** =org-todo-keywords=
:PROPERTIES:
:ID:       6edcb547-3712-45a8-a665-8f1e7f05cd37
:END:
The =org-todo-keywords= also need to be customized, the default keywords are just =TODO=, and =DONE=. I've thought of this for a while, and perhaps this will suffice:

#+caption: my todo keywords
| TODO Keyword | What it is                                                                                                                                                                                                     |
|--------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =TODO=       | Tasks that are not started, also not planned. There can be many of them.                                                                                                                                       |
| =NEXT=       | Tasks that are planned to do immediately.                                                                                                                                                                      |
| =WAIT=       | Tasks that needs other form of interaction in order for it to be set as =PROG= or =DONE= or =KILL=.                                                                                                            |
| =PROG=       | Tasks that are actively in working progress, these are usually the kind of tasks that can be done by myself, or have gone through the =WAIT= phase. Which also means that this can also revert back to =WAIT=. |
| =HOLD=       | The kind of tasks that suspended without an escalation (these things happens im my workplace).                                                                                                                 |
These =TODO= keywords are the ones that (supposed) to have further actions. I only have three keywords with no further actions:

#+caption: keywords with no further actions
| TODO keyword | What it is                                              |
|--------------+---------------------------------------------------------|
| =DONE=       | GG, well played!                                        |
| =DELEGATED=  | I got someone else doing my job, GG, well played!       |
| =KILL=       | Cancelled, or my boss gave me a task beyond my paygrade |

Translate these into /Emacs Lisp/:

#+caption: defining my own =org-todo-keywords=
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "NEXT(n!)" "PROG(p!)" "WAIT(w!)" "HOLD(h!)" "|" "DONE(d!)" "DELEGATED(l!)" "KILL(k!)")))
#+end_src
- each character inside the parentheses are the fast state selection, when you use ~C-c C-t~ in a heading, you only have to type the character to select the keyword.
- =~~= means to record the time of state changes.
  #+caption: example of state changes log
  #+begin_src org
    ,* TODO test
    - State "TODO"       from              [2024-03-14 Thu 22:10]
  #+end_src
*** Priority
Prioritizing tasks is important in my daily routines. And I would like to quickly identify the priority of all the tasks I have in my hand.

#+caption: org-priority setup
#+begin_src emacs-lisp
  (setq org-priority-highest ?A
        org-priority-lowest ?D
        org-priority-default ?B)

  (setq org-priority-faces
        '((?A . (:foreground "#bf616a" :weight bold :underline t))
          (?B . (:foreground "#d08770" :weight bold :underline t))
          (?C . (:foreground "#4c566a" :weight bold :underline t))
          (?D . (:foreground "#3b4252" :weight bold :underline t))))
#+end_src
This will set a list of priority from =A= to =D=, the default keybinding is ~C-c ,~.
*** Tags
Another useful way to implement labels and contexts for headlines, in =org-mode= tags must be preceeded and followed by a single colon (=:=), for example =:work:=, several tags can be specified, as in =:work:urgent=. Although I don't use tags that often, there are several variables that I should customize:
#+begin_src emacs-lisp
(setq org-use-tag-inheritance t
      org-tags-exclude-from-inheritance '("crypt"))
#+end_src
The first one should be obvious, I want my sub-level headlines to inherit the tags from their parent headline. the second one is the tag that should not be inherited. The =:crypt:= tag is usually used for tagging headlines that contains password etc. The default keybinding for inserting tag is ~C-c C-c~ when the point is in the headline, or ~C-c C-q~ when under a headline.
** Deadlines and Schedules
*** Time-stamp
In =org-mode= it's a timestamp with a special keywords. Adding timestamp can be done with ~C-c .~ inside a heading, to insert an inactive timestamp (that doesn't show in org-agenda) use ~C-c !~. This will only insert date, to also insert time, use a ~C-u~ prefix (e.g. ~C-u C-c .~ or ~C-u C-c !~).
*** Deadline
The default keybinding is ~C-c C-d~. Meaning the heading, with a keyword (can be =TODO= or any other), is supposed to be finished at that date. Use ~C-u C- C-d~ to remove a deadline from the heading.
#+caption: TODO task with a deadline
#+begin_src org
  ,* TODO test
  DEADLINE: <2024-03-14 Thu>
  - State "TODO"       from              [2024-03-14 Thu 22:10]
#+end_src
There are also different syntax for the date:
- ~DEADLINE: <2024-03-14 Thu -3d>~
  means a warning with the period of 3 days,
*** Schedule
Meaning that I'm planning to start doing the tasks at that date. The default keybinding is ~C-c C-s~, use ~C-u C-c C-s~ to remove a schedule from a heading.
#+caption: TODO task with a schedule
#+begin_src org
  ,* TODO test
  SCHEDULED: <2024-03-16 Sat 09:00>
  - State "TODO"       from              [2024-03-14 Thu 22:10]
#+end_src
Just as deadline, a different syntax also available:
- ~SCHEDULED: <2024-03-16 Sat 10:00 -2d>~
  means to delay the display of this task in the agenda for 2 day. The task is still scheduled on the 16th.
** The Agenda view.
=org-mode= has a builtin /agenda/. The default /Agenda views/ will show informations of:
- Agenda for the current week or day, with the default key ~a~.
- List of all =TODO= entries, key ~t~.
- Matching queries of /tags/, /properties/, or =TODO= keywords. With the key ~m~.
- ~s~, search for keywords.
- ~/~ for multi-occur (never tried this).
- ~?~ for finding flagged entries.
- ~*~ for toggling sticky agenda views.
- ~n~ for all agendas and =TODOs=.

The agenda view is what I use the most for reviewing all my tasks, luckily there's a package called [[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] that also display several items from your agenda.
#+caption: my /dashboard/
[[./emacs-dashboard.png][file:emacs-dashboard.png]]

#+caption: Vanilla Emacs =org-agenda=
[[./vanilla-emacs-org-agenda.png][file:vanilla-emacs-org-agenda.png]]

*** Configuring =org-agenda-custom-commands=
This is the meat of my workflow, so I should have the information I want with just pressing each keyword.
**** Viewing the custom agenda
***** today's section
This will show on the top of my custom agenda view, showing today's tasks.
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        `(("w" "work"
           ((agenda ""
                    ((org-agenda-span 1)
                     (org-agenda-start-on-weekday t)
                     (org-agenda-block-separator nil)
                     (org-agenda-use-time-grid t)
                     (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                     (org-agenda-format-date "%A %-e %B %Y")
                     (org-agenda-overriding-header "\nToday\n")))))))
#+end_src
- =org-agenda-span= :: number of days to include in overview display, default to ='week=.
- =org-deadline-warning-days= :: Number of days before expiration during which a deadline becomes active, default to =14=.
- =org-agenda-use-time-grid= :: Non-nil means show a time grid in agenda schedule.
This will show every tasks created today. For example, if I have a todo list like this:
#+begin_src org
  ,* Inbox
  ,** TODO Test Heading 2
  DEADLINE: <2024-03-15 Fri>
  :LOGBOOK:
  - State "TODO"       from              [2024-03-14 Thu 22:53]
  :END:
  <2024-03-14 Thu 11:00>
  ,** PROG Test Heading
  DEADLINE: <2024-03-14 Thu>
  :LOGBOOK:
  - State "PROG"       from              [2024-03-14 Thu 22:53]
  :END:
  <2024-03-14 Thu 09:34>
  ,** DONE Test HEADING 3
  <2024-03-14 Thu 14:00>
  CLOSED: [2024-03-14 Thu 22:54] SCHEDULED: <2024-03-18 Mon>
  :LOGBOOK:
  - State "DONE"       from              [2024-03-14 Thu 22:54]
  :END:

  ,** Test Heading 4
  DEADLINE: <2024-03-14 Thu 17:00>
#+end_src

Will create a custom view ~w~, with the first section marked "Today", the =\n= is for inserting new line:
#+caption: today's view
[[./org-agenda-custom-today.png][file:org-agenda-custom-today.png]]
***** Incomplete tasks section
Useful to remind me for tasks that has not yet completed.
#+caption: Incomplete tasks section addition
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        `(("w" "work"
           ((agenda ""
                    ((org-agenda-span 1)
                     (org-agenda-start-on-weekday t)
                     (org-agenda-block-separator nil)
                     (org-deadline-warning-days 0)
                     (org-scheduled-past-days 0)
                     (org-agenda-use-time-grid t)
                     (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                     (org-agenda-format-date "%A %-e %B %Y")
                     (org-agenda-overriding-header "\nToday\n")))
            (tags-todo "TODO=\"TODO\"|\"NEXT\""
                       ((org-agenda-block-separator nil)
                        (org-agenda-skip-function '(org-agenda-skip-if-todo 'nottodo 'done))
                        (org-agenda-use-time-grid nil)
                        (org-agenda-overriding-header "\nIncomplete\n")))))))
#+end_src
This second section is filtered by /tags/ (though it matches everything from /tags/, /properties/, and /TODO keywords/). The expression ~"-TODO=\"DONE\"|\"KILL\""~ means all /TODO keywords/ that matches =DONE= or =KILL=, notice that we need to espace the quote with =\= between each keywords.

The other notable filter is the =org-agenda-skip-function=, this will only show tasks that matches from the function ='(org-agenda-skip-entry-if'nottodo 'done)=, which as its name suggest, skip entry if =TODO= keyword is not the type ='done= (the keywords on the right side of the =|= as defined [[id:6edcb547-3712-45a8-a665-8f1e7f05cd37][here]]).
***** Section for everything else
This will show all the tasks for the current week. I intentionally set this weekly to limit the number of tasks that I should be aware of. No filter is set for this section just in case I created a task without schedule, deadline, or even a keyword.
#+caption: weekly view addition
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        `(("n" "Agenda"
           ((agenda ""
                    ((org-agenda-span 1)
                     (org-agenda-start-on-weekday t)
                     (org-agenda-block-separator nil)
                     (org-agenda-use-time-grid t)
                     (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                     (org-agenda-format-date "%A %-e %B %Y")
                     (org-agenda-overriding-header "\nToday\n")))
            (tags-todo "TODO=\"TODO\"|\"NEXT\""
                    ((org-agenda-block-separator nil)
                     (org-agenda-skip-function '(org-agenda-skip-if-todo 'nottodo 'done))
                     (org-agenda-use-time-grid nil)
                     (org-agenda-overriding-header "\nIncomplete\n")))
            (agenda ""
                    ((org-agenda-span 7)
                     (org-agenda-start-on-weekday 1)
                     (org-agenda-block-separator nil)
                     (org-agenda-use-time-grid nil)
                     (org-agenda-overriding-header "\nWeekly\n")))))))
#+end_src

#+caption: the modified =org-agenda-custom-commands=
[[./org-agenda-custom-commands-work.png][file:org-agenda-custom-commands-work.png]]

Now I have a view of my daily, weekly agenda, and list of incomplete tasks. I can easily move into each tasks with pressing ~RET~ (~ENTER~) at each task.
***** Separation of work and personal tasks
I personally don't use /org-agenda/ for anything else beside my work stuffs. But occasionally there's things that I put in my org files that are not work-related. For me, the easiest solution is just to use =org-tags= for all my personal tasks and use =org-agenda-tag-filter= in my agenda.

#+caption: filter by tag
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        `(("n" "Agenda and all TODOs"
           ((agenda ""
                    ((org-agenda-span 1)
                     (org-agenda-start-on-weekday t)
                     (org-agenda-block-separator nil)
                     (org-agenda-use-time-grid t)
                     (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                     (org-agenda-format-date "%A %-e %B %Y")
                     (org-agenda-overriding-header "\nToday\n")))
            (tags-todo "TODO=\"TODO\"|\"NEXT\""
                       ((org-agenda-block-separator nil)
                        (org-agenda-skip-function '(org-agenda-skip-if-todo 'nottodo 'done))
                        (org-agenda-use-time-grid nil)
                        (org-agenda-overriding-header "\nIncomplete\n")))
            (agenda ""
                    ((org-agenda-span 7)
                     (org-agenda-start-on-weekday 1)
                     (org-agenda-block-separator nil)
                     (org-agenda-use-time-grid nil)
                     (org-agenda-overriding-header "\nWeekly\n"))))
           ((org-agenda-tag-filter-preset '("-personal" "-home")))
           )))
#+end_src
the ="-personal"= and ="-home"= means to filter out every headlines with the tag =personal=, and =home=, if you have many of them, just create another /agenda view/ with that filter in reverse, using =+personal= or =+home=
***** Stuck Projects
In =org-mode= term, a /stuck project/ is a project (identified as a header) that has no defined next action, so it never shows up in the TODO list. The default value is:

#+caption: default =org-stuck-projects=
#+begin_src emacs-lisp
  (setq org-stuck-projects
        '("+LEVEL=2/-DONE"
          ("TODO" "NEXT" "NEXTACTION")
          nil ""))
#+end_src

It is a list with four items:
- a tag/todo/property matching a project.
- a list of todo keywords identifying non-stuck projects.
- a list of tags identifying non-stuck projects.
- a regular expression matching non stuck projects.

The default means that a project is a level 2 headlines with the tag =PROJECT= but not if it has a todo keyword =MAYBE= and =DONE=, and will not be considered a stuck project if it has a todo keyword =TODO=, =NEXT=, or =NEXTACTION=, the third and fourth item is =nil= so it has no tag filter and no regular expression matcher for non-stuck projects. 

So I simply just use the tag =project= for tasks that I considered as a project. Using the =org-todo-keywords= that I already setup earlier, my =org-stuck-projects= is:

#+caption: my =org-stuck-projects=
#+begin_src emacs-lisp
  (setq org-stuck-projects
        '("+LEVEL=2/-DONE/-DELEGATED/-KILL"
          ("TODO" "NEXT" "PROG")
          nil ""))
#+end_src

Then you can use org agenda to list all the stuck project with the key =#=, or with the command ~M-x org-agenda #~.
** Refiling and archiving
Eventually, the =org-files= used in my workflow will grow larger. So I will also need to move the previous tasks, refiling them into separate categories or even separate file. And also archiving them so they won't clutter my agenda views, and also keep my =org-agenda= faster without having to check all those completed tasks.
*** Archiving
The main goal is to keep my main inbox file (the first entry of tasks) empty as soon as possible. This is where /org-archive/ comes handy. The flow that I have in mind is to create a monthly file, perhaps in a headline consisting of =YYYY/MM= structure. The refiled entries are still monitored by /org-agenda/. I'd like to have some kind of /agenda view/ for these files for reviewing purpose, perhaps maybe exporting them to different formats.

#+caption: my =org-archive= setup
#+begin_src emacs-lisp
  (setq org-archive-location  (concat org-directory  "/archive.org::datetree/* Archived Tasks"))
#+end_src
This will set the archive location to a file named =archives.org= inside my =org-directory=, and within a first level headline named "Archived Tasks"
*** Refiling
Still with the goal of having an unclutter inbox file, I'm using =org-refile= feature to move tasks from my inbox into another file, mainly for tasks that need (or waiting for) several steps to complete. Mostly though, I use =org-refile= in order to categorize my tasks, for examples I prefer to put tasks that are related to projects (in term of my work project), into a file named =projects.org= inside my =org-directory=, and routine tasks into =routines.org=, and my personal stuffs in =personal.org=

#+caption: my =org-refile= setup
#+begin_src emacs-lisp
  (setq org-refile-targets
        `((,(expand-file-name "projects.org" org-directory) :maxlevel . 1)
          (,(expand-file-name "routines.org" org-directory) :maxlevel . 1)
          (,(expand-file-name "personal.org" org-directory) :maxlevel . 1))
        org-refile-use-outline-path 'file
        org-outline-path-complete-in-steps nil)
#+end_src
- =org-refile-use-outline-path= :: this is set to ='file= to provide the file name as the refile target. Necessary since I'm using multiple files.
- =org-outline-path-complete-in-steps= :: set to =nil= so the completions won't be set per step (filename -> headlines). Just to speed up the process.
- =:maxlevel= :: limits the level of headlines considered to be a target. A max level of 1 means only the top-level headlines. This also means that all the targets above can be set into one file (e.g. =refile.org=), and create a top-level headlines as the categories.

We'll also need to add a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html][hook]] to make sure that the target buffer is saved after the refiling process.

#+caption: refile hook
#+begin_src emacs-lisp
  (add-hook 'org-after-refile-insert-hook #'save-buffer)
#+end_src
*** Things of interest
- [[https://200ok.ch/posts/2022-02-13_integrating_org_mode_agenda_into_other_calendar_apps.html][Exporting /org-agenda/ to /thunderdbird/]] :: I use /thunderbird/, and also have setup my /thunderbird/ calendar to sync my /Outlook/ calendars using /[[https://davmail.sourceforge.net/][davmail]]/.
** Using =org-capture=
Of course all of the above would be useless if I have to manually create a task. At least I would like to have an /org-capture/ template to make this easier.

#+caption: org-capture-templates
#+begin_src emacs-lisp
  (require 'org-capture)
  (setq org-capture-templates
        `(("i" "Inbox" entry
           (file+headline ,(expand-file-name "inbox.org" org-directory) "Inbox")
           "** %?\n%i\n%a" :prepend t :jump-to-captured t)))
#+end_src

#+caption: org-capture in process
[[./org-capture-1.png][file:org-capture-1.png]]
[[./org-capture-2.png][file:org-capture-2.png]]
*** Capturing with templates

Let say there are some entries that usually have a similar format, we can provide a template for those entries. Name this =request.template= and put it inside the =org-directory=.
#+begin_example
,** TODO %?
:PROPERTIES:
:USER: %^{User}
:UNIT: %^{Unit|MKN|GMN|STN}
:CATEGORY: %^{Category|Meeting|Purchase|Repair|Assistance}
:REQUEST_VIA: %^{Request via|In Person|Phone/Messaging|Mail}
:ITEM: %^{Item}
:QTY: %^{Quantity|1}
:LINK: %a
:END:
:LOGBOOK:
- State "TODO"		from		%U
:END:

,*** Requirements
- [ ] Escalation
- [ ] Approval
#+end_example
This will create a template for a 2nd level heading, with org [[https://orgmode.org/manual/Properties-and-Columns.html][properties]] and a logbook [[https://orgmode.org/manual/Drawers.html][drawer]]. But we also need some inputs:
- =%^{User}= :: prompt for /User/.
- =%^{Category|Meeting|Purchage|Repair|Assistance}= :: Prompt for input with predefined values.
- =%a= :: Annotation, normally the link created with =org-store-link=.
- =%U= :: inactive timestamp for state tracking, only needed for the first time, will be updated automatically every time there's a state change.
- list started with =[ ]= means that it's a checkbox list, we can change the state to =[x]= using ~C-c C-c~.

#+caption: the org-capture-templates
#+begin_src emacs-lisp
  (add-to-list 'org-capture-templates
               `("r" "Request" entry (file+headline ,(expand-file-name "inbox.org" org-directory) "Request")
                 (file ,(expand-file-name "request.template" org-directory))))
#+end_src

#+caption: /org-capture/ with a predefined template
[[./org-capture-with-template-1.png][file:org-capture-with-template-1.png]]

#+caption: the content of the template
[[./org-capture-with-template-2.png][file:org-capture-with-template-2.png]]

#+caption: Prompt with completion
[[./org-capture-with-template-3.png][file:org-capture-with-template-3.png]]

#+caption: content of the capture target
[[./org-capture-with-template-4.png][file:org-capture-with-template-4.png]]

*** Things of interest
- [[https://bzg.fr/en/some-emacs-org-mode-features-you-may-not-know/][Using context-aware capture-templates]] :: the link is not just about =org-capture=.
* Synchronization
I mainly use /[[https://syncthing.net/][syncthing]]/ for synchronizing my =org-directory= across my devices. It has support for /android/, on which I use [[https://orgzly.com/][orgzly]] mostly for viewing the org files. Once you've set the repository inside /orgzly/ to point to =org-directory= (which already synced by /syncthing/), you're ready to go. Also don't forget to match the todo keywords with the one you've set in /Emacs/. The downside is you cannot attach to the org-file while in /orgzly/.

And, depending on your /android/ version, /syncthing/ cannot sync properly on some filesystems. So it's better to store your sync directory on the device internal storage than the external one.
* /org-mode/ extensions
Although all the configuration listed above is enough for my /task management/ workflow, there are many packages for /Emacs/ (builtin or external) to enhance your /org-mode/ experience. Here are some of them:
** =Evil-mode=
I made a separate post for this package. If you're coming from /Vim/, this is mandatory. If you're not, try the default /Emacs/ keybindings first, if your pinky fingers are not long enough, try this package.

#+caption: recommended /evil/ configuration
#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init
    (setq evil-want-integration t) ;; This is optional since it's already set to t by default.
    (setq evil-want-keybinding nil)
    :config
    (evil-mode 1))

  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (evil-collection-init)
    (with-eval-after-load 'org-agenda
      (evil-set-initial-state #'org-agenda-mode 'normal)
      (evil-define-key '(normal visual) org-agenda-mode-map
        "q" 'org-agenda-quit
        "Q" 'org-agenda-quit
        (kbd "<return>") 'org-agenda-switch-to
        "t" 'org-agenda-todo
        "gr" 'org-agenda-redo-all)))

#+end_src
** =org-fancy-priorities=
#+begin_src emacs-lisp
  (use-package org-fancy-priorities
    :ensure t
    :hook
    (org-mode . org-fancy-priorities-mode)
    :config
    (setq org-fancy-priorities-list '("⚡" "⬆" "⬇" "☕")))
#+end_src

#+caption: image from [[https://github.com/harrybournis/org-fancy-priorities][their readme page]]
[[https://github.com/harrybournis/org-fancy-priorities/raw/master/screenshots/screenshot1.png]]
** =org-modern=

#+caption: org-modern
[[./org-modern.png][file:org-modern.png]]
This package implements a modern style for your Org buffers using font locking and text properties. The package styles headlines, keywords, tables and source blocks. The styling is configurable, you can enable, disable or modify the style of each syntax element individually via the org-modern customization group.
#+caption: org-modern configuration (mainly from their [[https://github.com/minad/org-modern/][github page]])
#+begin_src emacs-lisp
  (use-package org-modern
    :ensure t
    :init
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (load-theme 'modus-vivendi t)
    :config
    (set-face-attribute 'org-modern-symbol nil :family "Iosevka Nerd Font")
    (set-face-attribute 'default nil :family "Iosevka Nerd Font Mono")
    (set-face-attribute 'variable-pitch nil :family "Iosevka Nerd Font Mono")
    (modify-all-frames-parameters
     '((right-divider-width . 40)
       (internal-border-width . 40)))
    (dolist (face '(window-divider
                    window-divider-first-pixel
                    window-divider-last-pixel))
      (face-spec-reset-face face)
      (set-face-foreground face (face-attribute 'default :background)))
    (set-face-background 'fringe (face-attribute 'default :background))
    (setq
     ;; Edit settings
     org-auto-align-tags nil
     org-tags-column 0
     org-catch-invisible-edits 'show-and-error
     org-special-ctrl-a/e t
     org-insert-heading-respect-content t

     ;; Org styling, hide markup etc.
     org-hide-emphasis-markers t
     org-pretty-entities t
     org-ellipsis "…"

     ;; Agenda styling
     org-agenda-tags-column 0
     org-agenda-block-separator ?─
     org-agenda-time-grid
     '((daily today require-timed)
       (800 1000 1200 1400 1600 1800 2000)
       " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
     org-agenda-current-time-string
     "◀── now ─────────────────────────────────────────────────")
    (global-org-modern-mode))
#+end_src

#+caption: org-modern agenda
[[./org-modern-agenda.png][file:org-modern-agenda.png]]
** builtin packages
When you visit a file, point goes to the last place where it was when you previously visited the save file.
*** =saveplace=
#+begin_src emacs-lisp
  (use-package saveplace
    :init
    (save-place-mode 1)
    :custom
    (save-place-file (expand-file-name "places" user-emacs-directory)))
#+end_src
*** =savehist=
Save the minibuffer history
#+begin_src emacs-lisp
  (use-package savehist
    :init
    (savehist-mode 1)
    :custom
    (savehist-file (expand-file-name "history" user-emacs-directory))
    (savehist-coding-system 'utf-8)
    (savehist-additional-variables
     '(evil-jumps-history
       kill-ring
       register-alist
       mark-ring
       global-mark-ring
       search-ring
       regexp-search-ring)))
#+end_src
*** various =files= configuration
#+begin_src emacs-lisp
  (use-package files
    :custom
    (find-file-visit-truename t)
    (version-control t)
    (backup-by-copying t)
    (delete-old-versions t)
    (kept-new-versions 6)
    (kept-old-versions 2)
    (auto-save-include-big-deletions t)
    (auto-save-list-file-prefix (expand-file-name ".autosave/" user-emacs-directory))
    (backup-directory-alist `(("." . ,(expand-file-name ".backup" user-emacs-directory)))))
#+end_src
- =find-file-visit-truename= :: if the visited file is a symlink, it will find the truename of the file instead.
- =version-control= :: make numeric backup versions unconditionally.
- =backup-by-copying= :: always use copying to create backup files.
- =delete-old-versions= :: delete excess backup versions silently
* Footnotes
[fn:1] By using another instance of /Emacs/, but with a specific command arguments:
#+begin_src sh
  emacs --init-directory=/dev/null
#+end_src
This will ensure /Emacs/ is started with no user configuration.
